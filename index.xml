<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stephen’s Life</title><link>https://stephenz22.github.io/</link><description>Recent content on Stephen’s Life</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 28 Mar 2023 19:39:47 +0800</lastBuildDate><atom:link href="https://stephenz22.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang基础-Interface</title><link>https://stephenz22.github.io/posts/go_interface/</link><pubDate>Tue, 28 Mar 2023 19:39:47 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_interface/</guid><description>Golang Interface Link to heading Golang 中的接口就是一组方法的签名。接口是 Golang 整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而 Golang 的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明
// go_interface.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) // Golang 中接口可以看作是一组方法的集合 // 当一个类型 T 实现了 I 接口的全部方法 我们可以认为 // T 类型实现了这个接口 // 这里暂时可以认为 T类型是 I 接口的子类（但要清楚 Golang 没有class 继承的概念） // 定义一个 Person 接口 type Person interface { walk() take() speak() } // 定义一个Human 结构体 type Human struct { Name string Age int } // 定义一个Adult 结构体 引入Human type Adult struct { Human WorkAddrs string } // Adult 以下三个方法 实现了 Person Interface 中定义的函数 func (a Adult) walk() { fmt.</description></item><item><title>Golang基础-Struct</title><link>https://stephenz22.github.io/posts/go_struct/</link><pubDate>Mon, 27 Mar 2023 22:20:33 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_struct/</guid><description>Struct（结构体） Link to heading Golang 中没有提供class 这一面向对象的概念，所以也不存在继承这一面向对象的一大特性。于此同时为了实现类似面向对象的一些特性，Golang 提供了Struct、Interface这两个语法。通过结构体的内嵌配合接口，同样可以实现类似面向对象编程的效果。
Go 语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go 语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称 struct。 也就是我们可以通过 struct 来定义自己的类型了。
// go_structs.go package main import &amp;#34;fmt&amp;#34; // 定义结构体 // 这里需要注意！！！ // 下面Person 结构体及结构体字段首字母均为大写 // 在Golang中不同于Ruby，命名规范上推荐使用用驼峰命名 // 若一个包中的 函数，结构体，等定义是时 首字母为小写. // 则该函数、结构体只能在当前包内使用，若为大写则可在其他包Import时在其他包内使用 // 结构体中的字段可以用成员变量来理解，类似于Ruby中类的属性 type Person struct { Name string Age int Addrs string StepNum int } // 方法 // Golang中将函数和方法做了区分(也肯能是我自己一直没有区分，不过问题不大) // Golang 的方法 需要一个接收者（receiver）这点和Ruby类似 // 只能为当前包内定义的类型 定义方法 // 同时方法的接收者 可以是一个值 也可以是一个指针 // 同时不支持方法重载 // 实现 Person 的实例方法 // 接收者类型为指针 func (p *Person) addStep(i int) { p.</description></item><item><title>Golang基础-array、slice、map</title><link>https://stephenz22.github.io/posts/go_slice_map/</link><pubDate>Sun, 26 Mar 2023 20:46:05 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_slice_map/</guid><description>Golang 数组 Link to heading 声明数组 Link to heading Go 语言提供了数组类型的数据结构。
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。
Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：
var name [长度] 类型
声明名称为names一个长度为 5，元素类型为字符串的:
var names [5]string 初始化数组 Link to heading 标准数组变量初始化:
var names = [5]string{&amp;#34;张学友&amp;#34;, &amp;#34;刘德华&amp;#34;, &amp;#34;黎明&amp;#34;, &amp;#34;郭富城&amp;#34;, &amp;#34;成龙&amp;#34;} 短变量初始化数组:
names2 := [5]string{&amp;#34;张学友&amp;#34;, &amp;#34;刘德华&amp;#34;, &amp;#34;黎明&amp;#34;, &amp;#34;郭富城&amp;#34;, &amp;#34;成龙&amp;#34;} 编译器推断长度：
names3 := []string{&amp;#34;张学友&amp;#34;, &amp;#34;刘德华&amp;#34;, &amp;#34;黎明&amp;#34;, &amp;#34;郭富城&amp;#34;, &amp;#34;成龙&amp;#34;} 完整代码:
package main import &amp;#34;fmt&amp;#34; func sum(arr [5]int) (sum int) { sum = 0 for i, n := range arr { fmt.</description></item><item><title>Golang基础-函数</title><link>https://stephenz22.github.io/posts/go_func/</link><pubDate>Fri, 24 Mar 2023 15:39:56 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_func/</guid><description>Golang 函数声明及调用 Link to heading 函数声明 Link to heading Golang 中函数的声明由四个部分组成需要用到func关键字，方法名，形参，返回值等下面来看一个几个完整的函数声明。同时在 Go 中，所有函数都必须直接声明在包级代码块中。 或者说，任何一个函数都不能被声明在另一个函数体内。 虽然匿名函数但匿名函数定义不属于函数声明。
// 函数返回匿名结果值 func addNumber(a int, b int) int { return a + b } // 函数返回具名结果值，返回值需使用小括号包裹 func addNumber(a int , b int) (c int) { c = a + b // 下面的return 等于 return return } // 多个返回结果值 func addOne(a, b, c int) (int, int, int) { return a + 1, b + 1, c + 1 } // 指针类型参数， 无返回值 func addTwo(a *int) { t := *a *a = t + 2 } Golang 的函数参数和返回值如果为具名，则可以看作是一个标准的的、省略了var关键字的变量声明表达式。</description></item><item><title>Golang基础-流程控制</title><link>https://stephenz22.github.io/posts/go_control_flow/</link><pubDate>Wed, 22 Mar 2023 18:36:59 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_control_flow/</guid><description>Golang 中流程控制简单介绍 Link to heading Golang 中包含三种基本的流程控制代码块:
if-else条件分支代码块； for循环代码块； switch-case多条件分支代码块； 同时 Golang 还提供了几种特定类型所使用的流程控制代码块:
容器类型相关的for-range循环代码块。 接口类型相关的type-switch多条件分支代码块。 通道类型相关的select-case多分支代码块。 和大部分现代语言一样，Golang 提供了break、continue、 goto、及fallthrough流程跳转关键字
下面来介绍三种基本流程控制语句的使用:
if-else条件分支控制代码块 Link to heading if-else 语句同大部分语言一致，一个完整的if-else条件分支控制语句的写法如下:
if initStatement; condition{ // code } else { // code } // initStatement 必须使用简单语句 // initStatement 可省略 // if a := 2; a &amp;gt; 3{ // fmt.Println(&amp;#34;大于三&amp;#34;) // } else { // fmt.Println(&amp;#34;小于三&amp;#34;) // } 代码演示如下：
// go_control_flow.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func printOdd(n uint32) { if n%2 == 0 { fmt.</description></item><item><title>Golang 基础语法-变量及作用域</title><link>https://stephenz22.github.io/posts/go_variable_basic_type/</link><pubDate>Mon, 20 Mar 2023 23:06:29 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_variable_basic_type/</guid><description>变量声明 Link to heading 在Goalng中声明变量有两种形式一种为标准形式，一种为短声明形式。标准形式的变量声明需要用到的var关键字。每个var关键字后面跟随一个变量名。下面演示这两种变量声明形式：
// go_variable_basic.go package main import &amp;#34;fmt&amp;#34; // 在函数外部声明的变量为全局变量或者包变量 // 在函数内部声明的变量为局部变量 // 标准形式 全局变量 var name, addr string = &amp;#34;张学友&amp;#34;, &amp;#34;中国香港&amp;#34; var age int = 62 // 标准形式利用类型推断 var school = &amp;#34;北京大学&amp;#34; var since = 1898 // 标准形式的省略初始值, 利用各自类型的默认值声明 var language string var compiled bool var number int func main() { fmt.Println(name, addr, age, school, language, compiled, number) // 短声明形式只可在函数内部使用，用来声明局部变量 // 注意！！！ // golang 当一个局部变量被声明之后至少要被使用一次 // 否则编译器将会报错， 全局变量则不受此限制 bookName := &amp;#34;局外人&amp;#34; fmt.</description></item><item><title>Golang 基础语法-常量</title><link>https://stephenz22.github.io/posts/go_syntax_basic01/</link><pubDate>Sat, 18 Mar 2023 20:38:22 +0800</pubDate><guid>https://stephenz22.github.io/posts/go_syntax_basic01/</guid><description>学习一门编程语言需要哪些步骤 Link to heading 变量定义 数据类型 条件语句 循环语句 多态继承 业务抽象 个人认为掌握以上列出的 6 条，就已经掌握现代编程语言所需要的最基础以及最常用的内容。剩下的就是在使用中不断的累积该语言的规范，约定，API 及语法糖。
现代编程语言仍需掌握一个开发脚手架，例如 Ruby 语言拥有 Ruby On Rails，Sinatra。Python 拥有 Django，Php 拥有 larvael, Golang 拥有 Beego，Gin 等。
语言是框架的基础，框架是语言的业务实现。框架可以帮助开发人员，快速的将，现实生活的事物，抽象成计算机世界的对象，并且在计算机世界开始生活。
如果说 Ruby 是一门最程序员有好的语言，那么当先互联网 IT 行业最炙手可热的语言当数Golang了。我本人第一次听说 Golang 应该是在 2017 年末, 通过Docker了解到 Golang，
当时并没有对其产生兴趣，但后来先后有俩个同事从 Ruby 栈转到 Golang，同时北京的求职市场上Ruby可谓惨不忍睹，我也开始有一搭没一搭开始学习尝试使用 Golang。
说起来，从第一行Hello World代码，到后来使用Gin实现一些 API，到现在也有三年左右的时间。随着这次 Blog 迁移，我这里打算记录一下Ruby 程序员是如何一步步学习一门静态强类型语言的.
Golang 基础语法简介 Link to heading 常量、变量、类变量、临时变量、实例变量 ， Ruby 的世界中关于变量的定于有许多种，其实日常工作中常用的也就几个。Golang 中仿佛关于变量的定义并没有 Ruby 那么区分，但还是有很大区别。
声明常量 Link to heading Golang中的变量及常量于大部分静态语言基本一致，需要提前进行声明其中常量声明的关键字为const、变量声明关键字为var，相信这两个关键字大家都不陌生，尤其是经常和javascript或typescript打交道的朋友。当然 golang 也提供了更加方便的变量定义语句，以及类型推断机制，以提高程序员编码效率。下面我们看一下变量及常量在Golang中的一些表现:</description></item><item><title>常见算法的Ruby实现</title><link>https://stephenz22.github.io/posts/sort_algorithm/</link><pubDate>Mon, 13 Mar 2023 19:40:10 +0800</pubDate><guid>https://stephenz22.github.io/posts/sort_algorithm/</guid><description>常见排序算法的 Ruby 实现 Link to heading 关于排序，可以说是算法的入门问题。每个程序员都有所了解或者熟悉。常见的如冒泡排序、选择排序、快速排序等。下面我会用Ruby语言来实现几个常见的排序算法，并对算法原理，及代码实现思路做出解释。
冒泡排序 Link to heading 关于冒泡排序，多数朋友都有耳闻，这里列出维基百科对冒泡排序的解释以供了解及加深印象
冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
好了，现在我们看一下冒泡排序的 Ruby 实现
# 冒泡排序 bubble sort def bubble_sort(nums) loop do mark = 0 (nums.length - 1).times do |i| if nums[i] &amp;gt; nums[i + 1] nums[i], nums[i + 1] = nums[i + 1], nums[i] mark = 1 end end break if mark.zero? end nums end # p bubble_sort([9,8,2,7,4,6,5,3,1]) # [1, 2, 3, 4, 5, 6, 7, 8, 9] # 下面利用递归实现一个冒泡排序 def bubble_sort_by_recurve(nums) mark = 0 (nums.</description></item><item><title>About</title><link>https://stephenz22.github.io/about/</link><pubDate>Mon, 13 Mar 2023 15:10:10 +0800</pubDate><guid>https://stephenz22.github.io/about/</guid><description>一名在北京以编写Ruby代码为生的音乐爱好者,于 16 年参加工作. 简单介绍一下过去几年的一些工作经历:
Program Language 使用Ruby语言, 及Ruby On Rails 框架开发 web 应用,熟悉 Ruby Mate Programming. BackEnd 数据库方面熟悉 Mysql, Postgresql, 以及Redis. FrontEnd 方面熟悉 Javascript 语言, Html, 不是很擅长 Css，但也经常进行样式方面的修改. 目前为离职状态，多年的工作后发现，自己不断的积累工作经验，学习各类技能，每次都太仓促了，导致自身的知识与技能不能很好的串联。这次离职的主要目的也是给自己一段放空的时间，梳理、总结、记录，对记录很重要过去 7 年的工作经验，掌握的技能，各类方法论。
我的邮箱: Stephenzhao94@163.com</description></item></channel></rss>